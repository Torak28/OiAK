# OiAK Projekt

Grupa **31**

* Wojciech Adles
* Jarosław Ciołek-Żelechowski

**Method to Design General RNS Reverse Converters for Extended Moduli Set**

# Matematyka

Na tym etapie skupiliśmy się na wymyśleniu własnego przykładu. 

### Dobranie danych:

Dla:

![baza](http://i.imgur.com/d8Y9IwY.png)

Próbowaliśmy początkowo różnych wariacji zgodnych z danymi przykładowymi. Nie wychodziło nam jednak powiązanie *k1* jako czegoś co liczymy a zarazem ma znaczenie dla samej bazy na podstawie której to liczymy.

Skorzystaliśmy z pomocy algorytmiki i napisaliśmy prosty skryp pythonowy:

```python
beta = 4
for n in range(1, 100):
    for k in range(1, 10000):
        rns = [(pow(2,n))-k,(pow(2,n))+k,(pow(2,n))+1,(pow(2,n))-1,(pow(2,n+beta))]
        if(rns[0] != 0):
            v1 = rns[1] % rns[0]
            v2 = rns[2] % rns[0]
            v3 = rns[3] % rns[0]
            v4 = rns[4] % rns[0]

            v = k * v1 * v2 * v3 * v4
            wynik = v % rns[0]
            if(wynik == 1):
                print "--------"
                print "n", n, "k", k
                print rns

{ 41, 87, 65, 63, 1024 }
{ n = 6 }
{ B = 4 }
{ k = 23 }
```

Podane pod koniec dane w nawiasach klamrowych oznaczają zestaw dla którego wszystkie ząłożenia z artykułu są prawdzie.

### Sam przykład

Mając dane gotowe, musieliśmy dosłownie wymyślić zestaw reszt. Wybraliśmy **<2, 2, 2, 2 ,3>**.

I tak naszą liczbą zapisaneą w naszej bazie jest **1'027'349'507**.

```
RNS = { 41, 87, 65, 63, 1024 }
set = { 2, 2, 2, 2, 3 }

gp > chinese(Mod(2,41),(chinese(Mod(2,87),chinese(Mod(2,65),chinese(Mod(2,63),Mod(3,1024))))))
%49 = Mod(1027349507, 4985809920)


{ 1027349507 }
{ bin =  0011 1101 0011 1100 0001 1100 0000 0011 }
{ hex = 3D 3C 1C 03 }
```